#!/bin/bash
source ./test_srcs/colors.sh
#source ./test_srcs/functions.sh
source ./test_srcs/options.sh
DIRECTORY=$(cd `dirname $0` && pwd)
PWD=${pwd}
OWNER=$(sed -n '6p' Makefile | cut -d ' ' -f6)
MAKEFILE_PATH=${pwd}Makefile
#OPTIONS
RM_TEST_DIR=1
TEST_P1=1
TEST_P2=1
TEST_BONUS=1
for OPTION in "$@"
do
	case "${OPTION}" in
		"-p1")				TEST_P1=1
			TEST_P2=0
			TEST_BONUS=0 ;;
		"-p2")				TEST_P1=0
			TEST_P2=1
			TEST_BONUS=0 ;;
		"-b")				TEST_P1=0
			TEST_P2=0
			TEST_BONUS=1 ;;
		"-s")				RM_TEST_DIR=0 ;;
	esac
done
LIB_NAME=$(grep "libft.a" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w libft.a)
ALL_RULE=$(grep "all" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w all)
NAME_RULE=$(grep "\${NAME}" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w \${NAME})
CLEAN_RULE=$(grep "clean" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w clean)
FCLEAN_RULE=$(grep "fclean" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w fclean)
RE_RULE=$(grep "re" ${MAKEFILE_PATH} | tr -d ' ' | tr -d '\t' | cut -d ':' -f 1 | grep -w re)
printf ${BOLD}${RED}"  _         _   _            _               _      _ _ _      __ _          \n"
printf " | |    ___| |_( )___    ___| |__   ___  ___| | __ | (_) |__  / _| |_   __ _ \n"
printf " | |   / _ \ __|// __|  / __| '_ \ / _ \/ __| |/ / | | | '_ \| |_| __| / _\` | \n"
printf " | |__|  __/ |_  \__ \ | (__| | | |  __/ (__|   <  | | | |_) |  _| |_ | (_| |\n"
printf " |_____\___|\__| |___/  \___|_| |_|\___|\___|_|\_\ |_|_|_.__/|_|  \__(_)__,_|\n\n"
printf " ============================================================================\n"
printf "\n"
printf ${BOLD}${BLUE}" ============================================================================\n"
printf " *				PROJECT CHECK				    *\n"
printf " ============================================================================\n"
printf "\n"${DEFAULT}
printf ${WHITE}"\033[4GCode owner"
printf "\033[30GMakefile"
printf "\033[56GHeader\n"
if [[ "$(for i in *.c; do sed -n '6p' $i | tail -1 | cut -f5 -d ' '; done | uniq | wc -l)" == "1" ]]; then
	printf ${GREEN}"\033[4G${OWNER}"
else
	printf ${RED}"\033[4GMultiple names ! "
fi
if [ -n "$(find ./ -type f -name "Makefile" -exec basename {} \;)" ];then
	printf ${GREEN}"\033[30G[OK]"
else
	printf ${RED}"\033[30G[KO]"
fi
if [ -n "$(find ./ -type f -name "libft.h" -exec basename {} \;)" ];then
	printf ${GREEN}"\033[56G[OK]\n"
else
	printf ${RED}"\033[56G[KO]\n"
fi
printf "\n"
printf ${BOLD}${BLUE}" ============================================================================\n"
printf " *				MAKEFILE CHECK				    *\n"
printf " ============================================================================\n"
printf "\n"${DEFAULT}
printf ${WHITE}"\033[4G\${NAME}"
printf "\033[17Gall"
printf "\033[30Gclean"
printf "\033[43Gfclean"
printf "\033[56Gre"
printf "\033[69Glibft.a\n"
if [[ "${NAME_RULE}" == *"\${NAME}"* ]]; then 
	printf ${GREEN}"\033[4G[OK]"
else
	printf ${RED}"\033[4G[KO]"
fi
if [[ "${ALL_RULE}" == *"all"* ]]; then 
	printf ${GREEN}"\033[17G[OK]"
else
	printf ${RED}"\033[17G[KO]"
fi
if [[ "${CLEAN_RULE}" == *"clean"* ]]; then 
	printf ${GREEN}"\033[30G[OK]"
else
	printf ${RED}"\033[30G[KO]"
fi
if [[ "${FCLEAN_RULE}" == *"fclean"* ]]; then 
	printf ${GREEN}"\033[43G[OK]"
else
	printf ${RED}"\033[43G[KO]"
fi
if [[ "${RE_RULE}" == *"re"* ]]; then 
	printf ${GREEN}"\033[56G[OK]"
else
	printf ${RED}"\033[56G[KO]"
fi
if [[ "${LIB_NAME}" == *"libft.a"* ]]; then 
	printf ${GREEN}"\033[69G[OK]\n"
else
	printf ${RED}"\033[69G[KO]\n"
fi
printf ${WHITE}"\n"
printf ${BOLD}${BLUE}" ============================================================================\n"
printf ${BOLD}${BLUE}" *				C FILES CHECK				    *\n"
printf ${BOLD}${BLUE}" ============================================================================\n"
printf ${BOLD}${BLUE}"\n"
printf ${WHITE}"\033[4GFunction"
printf "\033[24GFlags"
printf "\033[40GNorme"
printf "\033[52GTests\n"
printf ${WHITE}"\n"
part1=(
	'ft_atoi.c'
	'ft_bzero.c'
	'ft_calloc.c'
	'ft_isalnum.c'
	'ft_isalpha.c'
	'ft_isascii.c'
	'ft_isdigit.c'
	'ft_isprint.c'
	'ft_memccpy.c'
	'ft_memchr.c'
	'ft_memcmp.c'
	'ft_memcpy.c'
	'ft_memmove.c'
	'ft_memset.c'
	'ft_strchr.c'
	'ft_strdup.c'
	'ft_strlcat.c'
	'ft_strlcpy.c'
	'ft_strlen.c'
	'ft_strncmp.c'
	'ft_strnstr.c'
	'ft_tolower.c'
	'ft_toupper.c'
)
part2=(
	'ft_substr.c'
	'ft_strjoin.c'
	'ft_strtrim.c'
	'ft_split.c'
	'ft_itoa.c'
	'ft_strmapi.c'
	'ft_putchar_fd.c'
	'ft_putendl_fd.c'
	'ft_putnbr_fd.c'
	'ft_putstr_fd.c'
)
bonus=(
	'ft_lstadd_back.c'
	'ft_lstadd_front.c'
	'ft_lstclear.c'
	'ft_lstdelone.c'
	'ft_lstiter.c'
	'ft_lstlast.c'
	'ft_lstmap.c'
	'ft_lstnew.c'
	'ft_lstsize.c'
)

#Verify if functions respect norminette / compile and pass the tests
#function_breaker()
#{
#}
#
#if [ ${TEST_P1} -eq 1 ]; then
#	function_breaker "PART 1" ${part1[@]} ${CYAN}
#fi
#
#if [ ${TEST_P2} -eq 1 ]; then
#	function_breaker "PART 2" ${part2[@]} ${CYAN}
#fi
#
#if [ ${TEST_BONUS} -eq 1 ]; then
#	function_breaker "BONUS" ${bonus[@]} ${YELLOW}
#fi

#PART1

if [ ${TEST_P1} -eq 1 ]; then
	printf ${CYAN}"\033[31GPART 1\n"
	for val in ${part1[@]}; do
		printf ${CYAN}"\033[4G${val}"
		if [[ -z $(gcc -Wextra -Werror -Wall ./srcs/${val} ./tests_functions/main_${val} libft.a |& head -1) ]]; then
			printf ${GREEN}"\033[24G[OK]"
		else
			printf ${RED}"\033[24G[KO]"
		fi
		if [[ -z $(~/.norminette/norminette.rb ./srcs/${val} | grep "Error\|Warning") ]]; then
			printf ${GREEN}"\033[40G[OK]"
		else
			printf ${RED}"\033[40G[KO]"
		fi
		i=52
		test_num=1
		if test -f ./a.out; then
			./a.out > ./output/user/user_output_${val}
			while [ $i -le  70 ]; do
				if [[ -z $(diff ./output/expected/expected_output_${val} ./output/user/user_output_${val} | grep ${test_num}c${test_num}) ]]; then
					printf ${GREEN}"\033[${i}G"
				else
					printf ${RED}"\033[${i}G"
				fi
				test_num=$(($test_num+1))
				i=$(($i+2))
			done
		else
			printf ${RED}"\033[${i}GCompil error\n"
			continue
		fi
		printf "\n"
	done
	printf "\n"
fi

#PART2
if [ ${TEST_P2} -eq 1 ]; then
	printf ${CYAN}"\033[31GPART 2\n"
	for val in ${part2[@]}; do
		printf ${CYAN}"\033[4G${val}"
		if [[ -z $(gcc -Wextra -Werror -Wall ./srcs/${val} ./tests_functions/main_${val} libft.a |& head -1) ]]; then
			printf ${GREEN}"\033[24G[OK]"
		else
			printf ${RED}"\033[24G[KO]"
		fi
		if [[ -z $(~/.norminette/norminette.rb ./srcs/${val} | grep "Error\|Warning") ]]; then
			printf ${GREEN}"\033[40G[OK]"
		else
			printf ${RED}"\033[40G[KO]"
		fi
		i=52
		test_num=1
		if test -f ./a.out; then
			./a.out > ./output/user/user_output_${val}
			while [ $i -le  70 ]; do
				if [[ -z $(diff ./output/expected/expected_output_${val} ./output/user/user_output_${val} | grep ${test_num}c${test_num}) ]]; then
					printf ${GREEN}"\033[${i}G"
				else
					printf ${RED}"\033[${i}G"
				fi
				test_num=$(($test_num+1))
				i=$(($i+2))
			done
		else
			printf ${RED}"\033[${i}GCompil error\n"
			continue
		fi
		printf "\n"
	done
	printf "\n"
fi

#PARTBONUS
if [ ${TEST_BONUS} -eq 1 ]; then
	printf ${YELLOW}"\033[31GBONUS\n"
	for val in ${bonus[@]}; do
		printf ${YELLOW}"\033[4G${val}"
		if [[ -z $(gcc -Wextra -Werror -Wall ./srcs/${val} ./tests_functions/main_${val} libft.a |& head -1) ]]; then
			printf ${GREEN}"\033[24G[OK]"
		else
			printf ${RED}"\033[24G[KO]"
		fi
		if [[ -z $(~/.norminette/norminette.rb ./srcs/${val} | grep "Error\|Warning") ]]; then
			printf ${GREEN}"\033[40G[OK]"
		else
			printf ${RED}"\033[40G[KO]"
		fi
		i=52
		while [ $i -le  72 ]; do
			printf ${GREEN}"\033[${i}G"
			#printf ${RED}"\033[${i}G"
			i=$(($i+2))
		done
		printf "\n"
	done
	printf "\n"
fi
